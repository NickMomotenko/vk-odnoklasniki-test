# React + TypeScript + Vite

Demo - https://vk-odnoklasniki.netlify.app/

Setup instruction:
1. npm i
2. npm run dev - запуск локального сервера
3. npm run storybook - запуск storybook, там можно посмотреть все состояния компонентов и поклацать кнопки. 
Обосную несколько моментов по текущей работе.
В проекте есть несколько подкаталогов
	1.  components - Counter / Button - я сохранил в них самостоятельность использования. Т.е в практике мы можем использовать их по отдельности в любом виде, и их вид может быть изменен за счет передаваемых пропсов. На данный момент Button / Counter получают пропсы согласно макета, и исходя из этого меняется их стилистика. В тех задании не было указано что эти компоненты должны быть еще и кастомизированы, поэтому я не делал этого (имеется ввиду что можно было бы добавить пропсы, которые условно будут отвечать за полную кастомизацию компонента, условно если взять Counter, там можно было бы добавить counteBg , counterTextColor и подобные). 
	2.  compound - ButtonWithCounter - являет собой context , в него можно положить нужные компоненты , и относительно контекста вылавливать пропсы внутри Button / Counter. Я до этого не использовал никогда подход compound components, но в тестовом решил это попробовать. Сам подход по идеи дает жесткую стяжку между родительским compound и детьми, ибо без это обертки по идеи нет смысла как либо их использовать. Я пробовал привязать их условно таким способом ButtonWithCounter.Button = Button и ButtonWithCounter.Counter = Counter - в моем случае это работало, но убивалась самостоятельность Кнопки и Счетчика. Поэтому, возможно я упростил подход, и использую просто обертку -> внутри нее два компонента, в обертку вкидываю нужные пропсы, и ловлю их через контекст уже внутри Button и Counter, и относительно этого перерисовываю компоненты.
	3. Для того чтобы не вываливать логику изменения стилей от пропсов прям в компоненте - использую хуки, внутри которых уже и происходят все преобразования. По идеи получилось довольно лаконично.
	4. В проекте развернут story book , поэтому по ссылке Demo вы можете его просмотреть.
	5. Я не писал тесты для компонентов, в связи с нехваткой времени. Но я пробовал писать в другом проекте тесты через playwright, поэтому какой то условный опыт имеется.
Еще несколько моментов по реализации:
	1. сами по себе компоненты самостоятельны по отдельности, если же мы хотим их совместить - мы обязаны использовать обертку ButtonWithCounter и передавать именно в нее нужные пропсы. Если же не использовать обертку и просто совместить два компонента, то они отловят свои дефолтные состояния. Ибо условно Counter сам по себе имеет несколько view, но если он используется внутри Button , то относительно view Кнопки изменяется и стилистика Counter за счет новых пропсов.
	2. я видел что в тех задании есть рекомендация использовать stylus, я же использовал scss. Со stylus я знаком, принцип его достаточно похож в написании с scss. Но этот проект был написан давно, поэтому я не стал переписывать стили, а решил заморочится в тех реализации.
	3. по Counter -в ТЗ указано как именно должен вести себя компонент от значения value. В моем случае любое значение переданное будет приводится к типу Number, если цифра одна (кружок выглядит как кружок) или две то значение показывается как есть (кружок становится овалом), если значение больше 99 (значение заменяется на 99+). В ТЗ описан факто что если символов с типом string передано 3, то мы делаем какие то обрезки значения. Я не совсем понимаю когда может встретится такой кейс, еще и в случае что я дополнительно привожу к типу цифры.


Я опробовал много решений даже в контексте этой задачи, и крутил как только можно было. Единственный момент который я не учитывал, это если пойти по принципу жесткой связки , условно вот так и прокидывать пропсы в каждый по отдельности, но вроде бы по подходу compound components я не видел чтобы кто то так делал, все стараются за счет контекста спрятать логику, и уже непосредственно в компонентах ловить через контекст пропы. А все пропсы прокидывать через обертку.

    <ButtonWithCounter //общий контекст>
    	<ButtonWithCounter.Button // тут прям прокидывать пропсы для кнопки>
    		<ButtonWithCounter.Counter //тут прям прокидывать пропсы для счетчика>
    	</ButtonWithCounter.Counter>
    </ButtonWithCounter.Button></ButtonWithCounter>